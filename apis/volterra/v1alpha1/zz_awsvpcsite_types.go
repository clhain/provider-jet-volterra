/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AWSVPCSiteObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// +kubebuilder:validation:Optional
	IngressEgressGw []IngressEgressGwObservation `json:"ingressEgressGw,omitempty" tf:"ingress_egress_gw,omitempty"`

	// +kubebuilder:validation:Optional
	VoltstackCluster []VoltstackClusterObservation `json:"voltstackCluster,omitempty" tf:"voltstack_cluster,omitempty"`
}

type AWSVPCSiteParameters struct {

	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// +kubebuilder:validation:Optional
	AwsCred []AwsCredParameters `json:"awsCred,omitempty" tf:"aws_cred,omitempty"`

	// +kubebuilder:validation:Required
	AwsRegion *string `json:"awsRegion" tf:"aws_region,omitempty"`

	// +kubebuilder:validation:Optional
	BlockedServices []BlockedServicesParameters `json:"blockedServices,omitempty" tf:"blocked_services,omitempty"`

	// +kubebuilder:validation:Optional
	Coordinates []CoordinatesParameters `json:"coordinates,omitempty" tf:"coordinates,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultBlockedServices *bool `json:"defaultBlockedServices,omitempty" tf:"default_blocked_services,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DirectConnectDisabled *bool `json:"directConnectDisabled,omitempty" tf:"direct_connect_disabled,omitempty"`

	// +kubebuilder:validation:Optional
	DirectConnectEnabled []DirectConnectEnabledParameters `json:"directConnectEnabled,omitempty" tf:"direct_connect_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Disable *bool `json:"disable,omitempty" tf:"disable,omitempty"`

	// +kubebuilder:validation:Optional
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Optional
	IngressEgressGw []IngressEgressGwParameters `json:"ingressEgressGw,omitempty" tf:"ingress_egress_gw,omitempty"`

	// +kubebuilder:validation:Optional
	IngressGw []IngressGwParameters `json:"ingressGw,omitempty" tf:"ingress_gw,omitempty"`

	// +kubebuilder:validation:Required
	InstanceType *string `json:"instanceType" tf:"instance_type,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	LogReceiver []LogReceiverParameters `json:"logReceiver,omitempty" tf:"log_receiver,omitempty"`

	// +kubebuilder:validation:Optional
	LogsStreamingDisabled *bool `json:"logsStreamingDisabled,omitempty" tf:"logs_streaming_disabled,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	NoWorkerNodes *bool `json:"noWorkerNodes,omitempty" tf:"no_worker_nodes,omitempty"`

	// +kubebuilder:validation:Optional
	NodesPerAz *float64 `json:"nodesPerAz,omitempty" tf:"nodes_per_az,omitempty"`

	// +kubebuilder:validation:Optional
	OfflineSurvivabilityMode []OfflineSurvivabilityModeParameters `json:"offlineSurvivabilityMode,omitempty" tf:"offline_survivability_mode,omitempty"`

	// +kubebuilder:validation:Optional
	Os []OsParameters `json:"os,omitempty" tf:"os,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKey *string `json:"sshKey,omitempty" tf:"ssh_key,omitempty"`

	// +kubebuilder:validation:Optional
	SiteLocalControlPlane []SiteLocalControlPlaneParameters `json:"siteLocalControlPlane,omitempty" tf:"site_local_control_plane,omitempty"`

	// +kubebuilder:validation:Optional
	Sw []SwParameters `json:"sw,omitempty" tf:"sw,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	TotalNodes *float64 `json:"totalNodes,omitempty" tf:"total_nodes,omitempty"`

	// +kubebuilder:validation:Optional
	VPC []VPCParameters `json:"vpc,omitempty" tf:"vpc,omitempty"`

	// +kubebuilder:validation:Optional
	VoltstackCluster []VoltstackClusterParameters `json:"voltstackCluster,omitempty" tf:"voltstack_cluster,omitempty"`
}

type ActiveForwardProxyPoliciesForwardProxyPoliciesObservation struct {
}

type ActiveForwardProxyPoliciesForwardProxyPoliciesParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type ActiveForwardProxyPoliciesObservation struct {
}

type ActiveForwardProxyPoliciesParameters struct {

	// +kubebuilder:validation:Optional
	ForwardProxyPolicies []ForwardProxyPoliciesParameters `json:"forwardProxyPolicies,omitempty" tf:"forward_proxy_policies,omitempty"`
}

type ActiveNetworkPoliciesNetworkPoliciesObservation struct {
}

type ActiveNetworkPoliciesNetworkPoliciesParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type ActiveNetworkPoliciesObservation struct {
}

type ActiveNetworkPoliciesParameters struct {

	// +kubebuilder:validation:Optional
	NetworkPolicies []NetworkPoliciesParameters `json:"networkPolicies,omitempty" tf:"network_policies,omitempty"`
}

type AllowedVipPortCustomPortsObservation struct {
}

type AllowedVipPortCustomPortsParameters struct {

	// +kubebuilder:validation:Optional
	PortRanges *string `json:"portRanges,omitempty" tf:"port_ranges,omitempty"`
}

type AllowedVipPortObservation struct {
}

type AllowedVipPortParameters struct {

	// +kubebuilder:validation:Optional
	CustomPorts []CustomPortsParameters `json:"customPorts,omitempty" tf:"custom_ports,omitempty"`

	// +kubebuilder:validation:Optional
	UseHTTPHTTPSPort *bool `json:"useHttpHttpsPort,omitempty" tf:"use_http_https_port,omitempty"`

	// +kubebuilder:validation:Optional
	UseHTTPPort *bool `json:"useHttpPort,omitempty" tf:"use_http_port,omitempty"`

	// +kubebuilder:validation:Optional
	UseHTTPSPort *bool `json:"useHttpsPort,omitempty" tf:"use_https_port,omitempty"`
}

type AllowedVipPortSliCustomPortsObservation struct {
}

type AllowedVipPortSliCustomPortsParameters struct {

	// +kubebuilder:validation:Optional
	PortRanges *string `json:"portRanges,omitempty" tf:"port_ranges,omitempty"`
}

type AllowedVipPortSliObservation struct {
}

type AllowedVipPortSliParameters struct {

	// +kubebuilder:validation:Optional
	CustomPorts []AllowedVipPortSliCustomPortsParameters `json:"customPorts,omitempty" tf:"custom_ports,omitempty"`

	// +kubebuilder:validation:Optional
	UseHTTPHTTPSPort *bool `json:"useHttpHttpsPort,omitempty" tf:"use_http_https_port,omitempty"`

	// +kubebuilder:validation:Optional
	UseHTTPPort *bool `json:"useHttpPort,omitempty" tf:"use_http_port,omitempty"`

	// +kubebuilder:validation:Optional
	UseHTTPSPort *bool `json:"useHttpsPort,omitempty" tf:"use_https_port,omitempty"`
}

type AwsCredObservation struct {
}

type AwsCredParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type AzNodesLocalSubnetObservation struct {
}

type AzNodesLocalSubnetParameters struct {

	// +kubebuilder:validation:Optional
	ExistingSubnetID *string `json:"existingSubnetId,omitempty" tf:"existing_subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetParam []AzNodesLocalSubnetSubnetParamParameters `json:"subnetParam,omitempty" tf:"subnet_param,omitempty"`
}

type AzNodesLocalSubnetSubnetParamObservation struct {
}

type AzNodesLocalSubnetSubnetParamParameters struct {

	// +kubebuilder:validation:Optional
	IPv4 *string `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 *string `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type AzNodesObservation struct {
}

type AzNodesParameters struct {

	// +kubebuilder:validation:Optional
	AwsAzName *string `json:"awsAzName,omitempty" tf:"aws_az_name,omitempty"`

	// +kubebuilder:validation:Optional
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Optional
	InsideSubnet []InsideSubnetParameters `json:"insideSubnet,omitempty" tf:"inside_subnet,omitempty"`

	// +kubebuilder:validation:Optional
	OutsideSubnet []OutsideSubnetParameters `json:"outsideSubnet,omitempty" tf:"outside_subnet,omitempty"`

	// +kubebuilder:validation:Optional
	ReservedInsideSubnet *bool `json:"reservedInsideSubnet,omitempty" tf:"reserved_inside_subnet,omitempty"`

	// +kubebuilder:validation:Optional
	WorkloadSubnet []WorkloadSubnetParameters `json:"workloadSubnet,omitempty" tf:"workload_subnet,omitempty"`
}

type BlindfoldSecretInfoInternalObservation struct {
}

type BlindfoldSecretInfoInternalParameters struct {

	// +kubebuilder:validation:Optional
	DecryptionProvider *string `json:"decryptionProvider,omitempty" tf:"decryption_provider,omitempty"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// +kubebuilder:validation:Optional
	StoreProvider *string `json:"storeProvider,omitempty" tf:"store_provider,omitempty"`
}

type BlindfoldSecretInfoObservation struct {
}

type BlindfoldSecretInfoParameters struct {

	// +kubebuilder:validation:Optional
	DecryptionProvider *string `json:"decryptionProvider,omitempty" tf:"decryption_provider,omitempty"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// +kubebuilder:validation:Optional
	StoreProvider *string `json:"storeProvider,omitempty" tf:"store_provider,omitempty"`
}

type BlockedServicesObservation struct {
}

type BlockedServicesParameters struct {

	// +kubebuilder:validation:Optional
	BlockedSevice []BlockedSeviceParameters `json:"blockedSevice,omitempty" tf:"blocked_sevice,omitempty"`
}

type BlockedSeviceObservation struct {
}

type BlockedSeviceParameters struct {

	// +kubebuilder:validation:Optional
	DNS *bool `json:"dns,omitempty" tf:"dns,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkType *string `json:"networkType,omitempty" tf:"network_type,omitempty"`

	// +kubebuilder:validation:Optional
	SSH *bool `json:"ssh,omitempty" tf:"ssh,omitempty"`

	// +kubebuilder:validation:Optional
	WebUserInterface *bool `json:"webUserInterface,omitempty" tf:"web_user_interface,omitempty"`
}

type ClearSecretInfoObservation struct {
}

type ClearSecretInfoParameters struct {

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type CoordinatesObservation struct {
}

type CoordinatesParameters struct {

	// +kubebuilder:validation:Optional
	Latitude *float64 `json:"latitude,omitempty" tf:"latitude,omitempty"`

	// +kubebuilder:validation:Optional
	Longitude *float64 `json:"longitude,omitempty" tf:"longitude,omitempty"`
}

type CustomCertificateCustomHashAlgorithmsObservation struct {
}

type CustomCertificateCustomHashAlgorithmsParameters struct {

	// +kubebuilder:validation:Required
	HashAlgorithms []*string `json:"hashAlgorithms" tf:"hash_algorithms,omitempty"`
}

type CustomCertificateDisableOcspStaplingObservation struct {
}

type CustomCertificateDisableOcspStaplingParameters struct {
}

type CustomCertificateObservation struct {
}

type CustomCertificateParameters struct {

	// +kubebuilder:validation:Optional
	CertificateURL *string `json:"certificateUrl,omitempty" tf:"certificate_url,omitempty"`

	// +kubebuilder:validation:Optional
	CustomHashAlgorithms []CustomHashAlgorithmsParameters `json:"customHashAlgorithms,omitempty" tf:"custom_hash_algorithms,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DisableOcspStapling []DisableOcspStaplingParameters `json:"disableOcspStapling,omitempty" tf:"disable_ocsp_stapling,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateKey []PrivateKeyParameters `json:"privateKey,omitempty" tf:"private_key,omitempty"`

	// +kubebuilder:validation:Optional
	UseSystemDefaults []UseSystemDefaultsParameters `json:"useSystemDefaults,omitempty" tf:"use_system_defaults,omitempty"`
}

type CustomCertificatePrivateKeyObservation struct {
}

type CustomCertificatePrivateKeyParameters struct {

	// +kubebuilder:validation:Optional
	BlindfoldSecretInfo []PrivateKeyBlindfoldSecretInfoParameters `json:"blindfoldSecretInfo,omitempty" tf:"blindfold_secret_info,omitempty"`

	// +kubebuilder:validation:Optional
	BlindfoldSecretInfoInternal []PrivateKeyBlindfoldSecretInfoInternalParameters `json:"blindfoldSecretInfoInternal,omitempty" tf:"blindfold_secret_info_internal,omitempty"`

	// +kubebuilder:validation:Optional
	ClearSecretInfo []PrivateKeyClearSecretInfoParameters `json:"clearSecretInfo,omitempty" tf:"clear_secret_info,omitempty"`

	// +kubebuilder:validation:Optional
	SecretEncodingType *string `json:"secretEncodingType,omitempty" tf:"secret_encoding_type,omitempty"`

	// +kubebuilder:validation:Optional
	VaultSecretInfo []PrivateKeyVaultSecretInfoParameters `json:"vaultSecretInfo,omitempty" tf:"vault_secret_info,omitempty"`

	// +kubebuilder:validation:Optional
	WingmanSecretInfo []PrivateKeyWingmanSecretInfoParameters `json:"wingmanSecretInfo,omitempty" tf:"wingman_secret_info,omitempty"`
}

type CustomCertificateUseSystemDefaultsObservation struct {
}

type CustomCertificateUseSystemDefaultsParameters struct {
}

type CustomHashAlgorithmsObservation struct {
}

type CustomHashAlgorithmsParameters struct {

	// +kubebuilder:validation:Required
	HashAlgorithms []*string `json:"hashAlgorithms" tf:"hash_algorithms,omitempty"`
}

type CustomPortsObservation struct {
}

type CustomPortsParameters struct {

	// +kubebuilder:validation:Optional
	PortRanges *string `json:"portRanges,omitempty" tf:"port_ranges,omitempty"`
}

type CustomStaticRouteNexthopInterfaceObservation struct {
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`
}

type CustomStaticRouteNexthopInterfaceParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type CustomStaticRouteNexthopNexthopAddressObservation struct {
}

type CustomStaticRouteNexthopNexthopAddressParameters struct {

	// +kubebuilder:validation:Optional
	IPv4 []NexthopNexthopAddressIPv4Parameters `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 []NexthopNexthopAddressIPv6Parameters `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type CustomStaticRouteNexthopObservation struct {

	// +kubebuilder:validation:Optional
	Interface []NexthopInterfaceObservation `json:"interface,omitempty" tf:"interface,omitempty"`
}

type CustomStaticRouteNexthopParameters struct {

	// +kubebuilder:validation:Optional
	Interface []NexthopInterfaceParameters `json:"interface,omitempty" tf:"interface,omitempty"`

	// +kubebuilder:validation:Optional
	NexthopAddress []NexthopNexthopAddressParameters `json:"nexthopAddress,omitempty" tf:"nexthop_address,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type CustomStaticRouteObservation struct {

	// +kubebuilder:validation:Optional
	Nexthop []NexthopObservation `json:"nexthop,omitempty" tf:"nexthop,omitempty"`
}

type CustomStaticRouteParameters struct {

	// +kubebuilder:validation:Optional
	Attrs []*string `json:"attrs,omitempty" tf:"attrs,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	Nexthop []NexthopParameters `json:"nexthop,omitempty" tf:"nexthop,omitempty"`

	// +kubebuilder:validation:Optional
	Subnets []SubnetsParameters `json:"subnets,omitempty" tf:"subnets,omitempty"`
}

type CustomStaticRouteSubnetsIPv4Observation struct {
}

type CustomStaticRouteSubnetsIPv4Parameters struct {

	// +kubebuilder:validation:Optional
	Plen *float64 `json:"plen,omitempty" tf:"plen,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type CustomStaticRouteSubnetsIPv6Observation struct {
}

type CustomStaticRouteSubnetsIPv6Parameters struct {

	// +kubebuilder:validation:Optional
	Plen *float64 `json:"plen,omitempty" tf:"plen,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type CustomStaticRouteSubnetsObservation struct {
}

type CustomStaticRouteSubnetsParameters struct {

	// +kubebuilder:validation:Optional
	IPv4 []CustomStaticRouteSubnetsIPv4Parameters `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 []CustomStaticRouteSubnetsIPv6Parameters `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type DcClusterGroupInsideVnObservation struct {
}

type DcClusterGroupInsideVnParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type DcClusterGroupObservation struct {
}

type DcClusterGroupOutsideVnObservation struct {
}

type DcClusterGroupOutsideVnParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type DcClusterGroupParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type DirectConnectEnabledObservation struct {
}

type DirectConnectEnabledParameters struct {

	// +kubebuilder:validation:Optional
	AutoAsn *bool `json:"autoAsn,omitempty" tf:"auto_asn,omitempty"`

	// +kubebuilder:validation:Optional
	CloudAggregatedPrefix []*string `json:"cloudAggregatedPrefix,omitempty" tf:"cloud_aggregated_prefix,omitempty"`

	// +kubebuilder:validation:Optional
	CustomAsn *float64 `json:"customAsn,omitempty" tf:"custom_asn,omitempty"`

	// +kubebuilder:validation:Optional
	DcConnectAggregatedPrefix []*string `json:"dcConnectAggregatedPrefix,omitempty" tf:"dc_connect_aggregated_prefix,omitempty"`

	// +kubebuilder:validation:Optional
	HostedVifs []HostedVifsParameters `json:"hostedVifs,omitempty" tf:"hosted_vifs,omitempty"`

	// +kubebuilder:validation:Optional
	ManualGw *bool `json:"manualGw,omitempty" tf:"manual_gw,omitempty"`

	// +kubebuilder:validation:Optional
	StandardVifs *bool `json:"standardVifs,omitempty" tf:"standard_vifs,omitempty"`
}

type DisableOcspStaplingObservation struct {
}

type DisableOcspStaplingParameters struct {
}

type DomainMatchObservation struct {
}

type DomainMatchParameters struct {

	// +kubebuilder:validation:Optional
	ExactValue *string `json:"exactValue,omitempty" tf:"exact_value,omitempty"`

	// +kubebuilder:validation:Optional
	RegexValue *string `json:"regexValue,omitempty" tf:"regex_value,omitempty"`

	// +kubebuilder:validation:Optional
	SuffixValue *string `json:"suffixValue,omitempty" tf:"suffix_value,omitempty"`
}

type EnableForwardProxyObservation struct {
}

type EnableForwardProxyParameters struct {

	// +kubebuilder:validation:Optional
	ConnectionTimeout *float64 `json:"connectionTimeout,omitempty" tf:"connection_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	MaxConnectAttempts *float64 `json:"maxConnectAttempts,omitempty" tf:"max_connect_attempts,omitempty"`

	// +kubebuilder:validation:Optional
	NoInterception *bool `json:"noInterception,omitempty" tf:"no_interception,omitempty"`

	// +kubebuilder:validation:Optional
	TLSIntercept []TLSInterceptParameters `json:"tlsIntercept,omitempty" tf:"tls_intercept,omitempty"`

	// +kubebuilder:validation:Optional
	WhiteListedPorts []*float64 `json:"whiteListedPorts,omitempty" tf:"white_listed_ports,omitempty"`

	// +kubebuilder:validation:Optional
	WhiteListedPrefixes []*string `json:"whiteListedPrefixes,omitempty" tf:"white_listed_prefixes,omitempty"`
}

type EnableForwardProxyTLSInterceptObservation struct {
}

type EnableForwardProxyTLSInterceptParameters struct {

	// +kubebuilder:validation:Optional
	CustomCertificate []TLSInterceptCustomCertificateParameters `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	EnableForAllDomains *bool `json:"enableForAllDomains,omitempty" tf:"enable_for_all_domains,omitempty"`

	// +kubebuilder:validation:Optional
	Policy []TLSInterceptPolicyParameters `json:"policy,omitempty" tf:"policy,omitempty"`

	// +kubebuilder:validation:Optional
	TrustedCAURL *string `json:"trustedCaUrl,omitempty" tf:"trusted_ca_url,omitempty"`

	// +kubebuilder:validation:Optional
	VolterraCertificate *bool `json:"volterraCertificate,omitempty" tf:"volterra_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	VolterraTrustedCA *bool `json:"volterraTrustedCa,omitempty" tf:"volterra_trusted_ca,omitempty"`
}

type ForwardProxyPoliciesObservation struct {
}

type ForwardProxyPoliciesParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type GlobalNetworkConnectionsEnableForwardProxyObservation struct {
}

type GlobalNetworkConnectionsEnableForwardProxyParameters struct {

	// +kubebuilder:validation:Optional
	ConnectionTimeout *float64 `json:"connectionTimeout,omitempty" tf:"connection_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	MaxConnectAttempts *float64 `json:"maxConnectAttempts,omitempty" tf:"max_connect_attempts,omitempty"`

	// +kubebuilder:validation:Optional
	NoInterception *bool `json:"noInterception,omitempty" tf:"no_interception,omitempty"`

	// +kubebuilder:validation:Optional
	TLSIntercept []EnableForwardProxyTLSInterceptParameters `json:"tlsIntercept,omitempty" tf:"tls_intercept,omitempty"`

	// +kubebuilder:validation:Optional
	WhiteListedPorts []*float64 `json:"whiteListedPorts,omitempty" tf:"white_listed_ports,omitempty"`

	// +kubebuilder:validation:Optional
	WhiteListedPrefixes []*string `json:"whiteListedPrefixes,omitempty" tf:"white_listed_prefixes,omitempty"`
}

type GlobalNetworkConnectionsObservation struct {

	// +kubebuilder:validation:Optional
	SLOToGlobalDr []SLOToGlobalDrObservation `json:"sloToGlobalDr,omitempty" tf:"slo_to_global_dr,omitempty"`

	// +kubebuilder:validation:Optional
	SliToGlobalDr []SliToGlobalDrObservation `json:"sliToGlobalDr,omitempty" tf:"sli_to_global_dr,omitempty"`
}

type GlobalNetworkConnectionsParameters struct {

	// +kubebuilder:validation:Optional
	DisableForwardProxy *bool `json:"disableForwardProxy,omitempty" tf:"disable_forward_proxy,omitempty"`

	// +kubebuilder:validation:Optional
	EnableForwardProxy []EnableForwardProxyParameters `json:"enableForwardProxy,omitempty" tf:"enable_forward_proxy,omitempty"`

	// +kubebuilder:validation:Optional
	SLOToGlobalDr []SLOToGlobalDrParameters `json:"sloToGlobalDr,omitempty" tf:"slo_to_global_dr,omitempty"`

	// +kubebuilder:validation:Optional
	SliToGlobalDr []SliToGlobalDrParameters `json:"sliToGlobalDr,omitempty" tf:"sli_to_global_dr,omitempty"`
}

type GlobalNetworkConnectionsSLOToGlobalDrGlobalVnObservation struct {
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`
}

type GlobalNetworkConnectionsSLOToGlobalDrGlobalVnParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type GlobalNetworkConnectionsSLOToGlobalDrObservation struct {

	// +kubebuilder:validation:Optional
	GlobalVn []GlobalNetworkConnectionsSLOToGlobalDrGlobalVnObservation `json:"globalVn,omitempty" tf:"global_vn,omitempty"`
}

type GlobalNetworkConnectionsSLOToGlobalDrParameters struct {

	// +kubebuilder:validation:Optional
	GlobalVn []GlobalNetworkConnectionsSLOToGlobalDrGlobalVnParameters `json:"globalVn,omitempty" tf:"global_vn,omitempty"`
}

type GlobalNetworkConnectionsSliToGlobalDrObservation struct {

	// +kubebuilder:validation:Optional
	GlobalVn []SliToGlobalDrGlobalVnObservation `json:"globalVn,omitempty" tf:"global_vn,omitempty"`
}

type GlobalNetworkConnectionsSliToGlobalDrParameters struct {

	// +kubebuilder:validation:Optional
	GlobalVn []SliToGlobalDrGlobalVnParameters `json:"globalVn,omitempty" tf:"global_vn,omitempty"`
}

type GlobalNetworkListGlobalNetworkConnectionsObservation struct {

	// +kubebuilder:validation:Optional
	SLOToGlobalDr []GlobalNetworkConnectionsSLOToGlobalDrObservation `json:"sloToGlobalDr,omitempty" tf:"slo_to_global_dr,omitempty"`

	// +kubebuilder:validation:Optional
	SliToGlobalDr []GlobalNetworkConnectionsSliToGlobalDrObservation `json:"sliToGlobalDr,omitempty" tf:"sli_to_global_dr,omitempty"`
}

type GlobalNetworkListGlobalNetworkConnectionsParameters struct {

	// +kubebuilder:validation:Optional
	DisableForwardProxy *bool `json:"disableForwardProxy,omitempty" tf:"disable_forward_proxy,omitempty"`

	// +kubebuilder:validation:Optional
	EnableForwardProxy []GlobalNetworkConnectionsEnableForwardProxyParameters `json:"enableForwardProxy,omitempty" tf:"enable_forward_proxy,omitempty"`

	// +kubebuilder:validation:Optional
	SLOToGlobalDr []GlobalNetworkConnectionsSLOToGlobalDrParameters `json:"sloToGlobalDr,omitempty" tf:"slo_to_global_dr,omitempty"`

	// +kubebuilder:validation:Optional
	SliToGlobalDr []GlobalNetworkConnectionsSliToGlobalDrParameters `json:"sliToGlobalDr,omitempty" tf:"sli_to_global_dr,omitempty"`
}

type GlobalNetworkListObservation struct {

	// +kubebuilder:validation:Optional
	GlobalNetworkConnections []GlobalNetworkConnectionsObservation `json:"globalNetworkConnections,omitempty" tf:"global_network_connections,omitempty"`
}

type GlobalNetworkListParameters struct {

	// +kubebuilder:validation:Optional
	GlobalNetworkConnections []GlobalNetworkConnectionsParameters `json:"globalNetworkConnections,omitempty" tf:"global_network_connections,omitempty"`
}

type GlobalVnObservation struct {
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`
}

type GlobalVnParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type HostedVifsObservation struct {
}

type HostedVifsParameters struct {

	// +kubebuilder:validation:Optional
	Vifs []*string `json:"vifs,omitempty" tf:"vifs,omitempty"`
}

type IPv4Observation struct {
}

type IPv4Parameters struct {

	// +kubebuilder:validation:Optional
	Addr *string `json:"addr,omitempty" tf:"addr,omitempty"`
}

type IPv6Observation struct {
}

type IPv6Parameters struct {

	// +kubebuilder:validation:Optional
	Addr *string `json:"addr,omitempty" tf:"addr,omitempty"`
}

type IngressEgressGwObservation struct {

	// +kubebuilder:validation:Optional
	GlobalNetworkList []GlobalNetworkListObservation `json:"globalNetworkList,omitempty" tf:"global_network_list,omitempty"`

	// +kubebuilder:validation:Optional
	InsideStaticRoutes []InsideStaticRoutesObservation `json:"insideStaticRoutes,omitempty" tf:"inside_static_routes,omitempty"`

	// +kubebuilder:validation:Optional
	OutsideStaticRoutes []OutsideStaticRoutesObservation `json:"outsideStaticRoutes,omitempty" tf:"outside_static_routes,omitempty"`
}

type IngressEgressGwParameters struct {

	// +kubebuilder:validation:Optional
	ActiveForwardProxyPolicies []ActiveForwardProxyPoliciesParameters `json:"activeForwardProxyPolicies,omitempty" tf:"active_forward_proxy_policies,omitempty"`

	// +kubebuilder:validation:Optional
	ActiveNetworkPolicies []ActiveNetworkPoliciesParameters `json:"activeNetworkPolicies,omitempty" tf:"active_network_policies,omitempty"`

	// +kubebuilder:validation:Optional
	AllowedVipPort []AllowedVipPortParameters `json:"allowedVipPort,omitempty" tf:"allowed_vip_port,omitempty"`

	// +kubebuilder:validation:Optional
	AllowedVipPortSli []AllowedVipPortSliParameters `json:"allowedVipPortSli,omitempty" tf:"allowed_vip_port_sli,omitempty"`

	// +kubebuilder:validation:Optional
	AwsCertifiedHw *string `json:"awsCertifiedHw,omitempty" tf:"aws_certified_hw,omitempty"`

	// +kubebuilder:validation:Optional
	AzNodes []AzNodesParameters `json:"azNodes,omitempty" tf:"az_nodes,omitempty"`

	// +kubebuilder:validation:Optional
	DcClusterGroupInsideVn []DcClusterGroupInsideVnParameters `json:"dcClusterGroupInsideVn,omitempty" tf:"dc_cluster_group_inside_vn,omitempty"`

	// +kubebuilder:validation:Optional
	DcClusterGroupOutsideVn []DcClusterGroupOutsideVnParameters `json:"dcClusterGroupOutsideVn,omitempty" tf:"dc_cluster_group_outside_vn,omitempty"`

	// +kubebuilder:validation:Optional
	ForwardProxyAllowAll *bool `json:"forwardProxyAllowAll,omitempty" tf:"forward_proxy_allow_all,omitempty"`

	// +kubebuilder:validation:Optional
	GlobalNetworkList []GlobalNetworkListParameters `json:"globalNetworkList,omitempty" tf:"global_network_list,omitempty"`

	// +kubebuilder:validation:Optional
	InsideStaticRoutes []InsideStaticRoutesParameters `json:"insideStaticRoutes,omitempty" tf:"inside_static_routes,omitempty"`

	// +kubebuilder:validation:Optional
	NoDcClusterGroup *bool `json:"noDcClusterGroup,omitempty" tf:"no_dc_cluster_group,omitempty"`

	// +kubebuilder:validation:Optional
	NoForwardProxy *bool `json:"noForwardProxy,omitempty" tf:"no_forward_proxy,omitempty"`

	// +kubebuilder:validation:Optional
	NoGlobalNetwork *bool `json:"noGlobalNetwork,omitempty" tf:"no_global_network,omitempty"`

	// +kubebuilder:validation:Optional
	NoInsideStaticRoutes *bool `json:"noInsideStaticRoutes,omitempty" tf:"no_inside_static_routes,omitempty"`

	// +kubebuilder:validation:Optional
	NoNetworkPolicy *bool `json:"noNetworkPolicy,omitempty" tf:"no_network_policy,omitempty"`

	// +kubebuilder:validation:Optional
	NoOutsideStaticRoutes *bool `json:"noOutsideStaticRoutes,omitempty" tf:"no_outside_static_routes,omitempty"`

	// +kubebuilder:validation:Optional
	OutsideStaticRoutes []OutsideStaticRoutesParameters `json:"outsideStaticRoutes,omitempty" tf:"outside_static_routes,omitempty"`

	// +kubebuilder:validation:Optional
	SmConnectionPublicIP *bool `json:"smConnectionPublicIp,omitempty" tf:"sm_connection_public_ip,omitempty"`

	// +kubebuilder:validation:Optional
	SmConnectionPvtIP *bool `json:"smConnectionPvtIp,omitempty" tf:"sm_connection_pvt_ip,omitempty"`
}

type IngressGwAllowedVipPortObservation struct {
}

type IngressGwAllowedVipPortParameters struct {

	// +kubebuilder:validation:Optional
	CustomPorts []AllowedVipPortCustomPortsParameters `json:"customPorts,omitempty" tf:"custom_ports,omitempty"`

	// +kubebuilder:validation:Optional
	UseHTTPHTTPSPort *bool `json:"useHttpHttpsPort,omitempty" tf:"use_http_https_port,omitempty"`

	// +kubebuilder:validation:Optional
	UseHTTPPort *bool `json:"useHttpPort,omitempty" tf:"use_http_port,omitempty"`

	// +kubebuilder:validation:Optional
	UseHTTPSPort *bool `json:"useHttpsPort,omitempty" tf:"use_https_port,omitempty"`
}

type IngressGwAzNodesObservation struct {
}

type IngressGwAzNodesParameters struct {

	// +kubebuilder:validation:Optional
	AwsAzName *string `json:"awsAzName,omitempty" tf:"aws_az_name,omitempty"`

	// +kubebuilder:validation:Optional
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Optional
	LocalSubnet []LocalSubnetParameters `json:"localSubnet,omitempty" tf:"local_subnet,omitempty"`
}

type IngressGwObservation struct {
}

type IngressGwParameters struct {

	// +kubebuilder:validation:Optional
	AllowedVipPort []IngressGwAllowedVipPortParameters `json:"allowedVipPort,omitempty" tf:"allowed_vip_port,omitempty"`

	// +kubebuilder:validation:Optional
	AwsCertifiedHw *string `json:"awsCertifiedHw,omitempty" tf:"aws_certified_hw,omitempty"`

	// +kubebuilder:validation:Optional
	AzNodes []IngressGwAzNodesParameters `json:"azNodes,omitempty" tf:"az_nodes,omitempty"`
}

type InsideStaticRoutesObservation struct {

	// +kubebuilder:validation:Optional
	StaticRouteList []StaticRouteListObservation `json:"staticRouteList,omitempty" tf:"static_route_list,omitempty"`
}

type InsideStaticRoutesParameters struct {

	// +kubebuilder:validation:Optional
	StaticRouteList []StaticRouteListParameters `json:"staticRouteList,omitempty" tf:"static_route_list,omitempty"`
}

type InsideSubnetObservation struct {
}

type InsideSubnetParameters struct {

	// +kubebuilder:validation:Optional
	ExistingSubnetID *string `json:"existingSubnetId,omitempty" tf:"existing_subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetParam []SubnetParamParameters `json:"subnetParam,omitempty" tf:"subnet_param,omitempty"`
}

type InterceptionRulesDomainMatchObservation struct {
}

type InterceptionRulesDomainMatchParameters struct {

	// +kubebuilder:validation:Optional
	ExactValue *string `json:"exactValue,omitempty" tf:"exact_value,omitempty"`

	// +kubebuilder:validation:Optional
	RegexValue *string `json:"regexValue,omitempty" tf:"regex_value,omitempty"`

	// +kubebuilder:validation:Optional
	SuffixValue *string `json:"suffixValue,omitempty" tf:"suffix_value,omitempty"`
}

type InterceptionRulesObservation struct {
}

type InterceptionRulesParameters struct {

	// +kubebuilder:validation:Optional
	DisableInterception *bool `json:"disableInterception,omitempty" tf:"disable_interception,omitempty"`

	// +kubebuilder:validation:Optional
	DomainMatch []DomainMatchParameters `json:"domainMatch,omitempty" tf:"domain_match,omitempty"`

	// +kubebuilder:validation:Optional
	EnableInterception *bool `json:"enableInterception,omitempty" tf:"enable_interception,omitempty"`
}

type InterfaceObservation struct {
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`
}

type InterfaceParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type K8SClusterObservation struct {
}

type K8SClusterParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type LocalSubnetObservation struct {
}

type LocalSubnetParameters struct {

	// +kubebuilder:validation:Optional
	ExistingSubnetID *string `json:"existingSubnetId,omitempty" tf:"existing_subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetParam []LocalSubnetSubnetParamParameters `json:"subnetParam,omitempty" tf:"subnet_param,omitempty"`
}

type LocalSubnetSubnetParamObservation struct {
}

type LocalSubnetSubnetParamParameters struct {

	// +kubebuilder:validation:Optional
	IPv4 *string `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 *string `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type LogReceiverObservation struct {
}

type LogReceiverParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type NetworkPoliciesObservation struct {
}

type NetworkPoliciesParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type NewVPCObservation struct {
}

type NewVPCParameters struct {

	// +kubebuilder:validation:Optional
	AllocateIPv6 *bool `json:"allocateIpv6,omitempty" tf:"allocate_ipv6,omitempty"`

	// +kubebuilder:validation:Optional
	Autogenerate *bool `json:"autogenerate,omitempty" tf:"autogenerate,omitempty"`

	// +kubebuilder:validation:Optional
	NameTag *string `json:"nameTag,omitempty" tf:"name_tag,omitempty"`

	// +kubebuilder:validation:Optional
	PrimaryIPv4 *string `json:"primaryIpv4,omitempty" tf:"primary_ipv4,omitempty"`
}

type NexthopAddressIPv4Observation struct {
}

type NexthopAddressIPv4Parameters struct {

	// +kubebuilder:validation:Optional
	Addr *string `json:"addr,omitempty" tf:"addr,omitempty"`
}

type NexthopAddressIPv6Observation struct {
}

type NexthopAddressIPv6Parameters struct {

	// +kubebuilder:validation:Optional
	Addr *string `json:"addr,omitempty" tf:"addr,omitempty"`
}

type NexthopAddressObservation struct {
}

type NexthopAddressParameters struct {

	// +kubebuilder:validation:Optional
	IPv4 []IPv4Parameters `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 []IPv6Parameters `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type NexthopInterfaceObservation struct {
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`
}

type NexthopInterfaceParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type NexthopNexthopAddressIPv4Observation struct {
}

type NexthopNexthopAddressIPv4Parameters struct {

	// +kubebuilder:validation:Optional
	Addr *string `json:"addr,omitempty" tf:"addr,omitempty"`
}

type NexthopNexthopAddressIPv6Observation struct {
}

type NexthopNexthopAddressIPv6Parameters struct {

	// +kubebuilder:validation:Optional
	Addr *string `json:"addr,omitempty" tf:"addr,omitempty"`
}

type NexthopNexthopAddressObservation struct {
}

type NexthopNexthopAddressParameters struct {

	// +kubebuilder:validation:Optional
	IPv4 []NexthopAddressIPv4Parameters `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 []NexthopAddressIPv6Parameters `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type NexthopObservation struct {

	// +kubebuilder:validation:Optional
	Interface []InterfaceObservation `json:"interface,omitempty" tf:"interface,omitempty"`
}

type NexthopParameters struct {

	// +kubebuilder:validation:Optional
	Interface []InterfaceParameters `json:"interface,omitempty" tf:"interface,omitempty"`

	// +kubebuilder:validation:Optional
	NexthopAddress []NexthopAddressParameters `json:"nexthopAddress,omitempty" tf:"nexthop_address,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type OfflineSurvivabilityModeObservation struct {
}

type OfflineSurvivabilityModeParameters struct {

	// +kubebuilder:validation:Optional
	EnableOfflineSurvivabilityMode *bool `json:"enableOfflineSurvivabilityMode,omitempty" tf:"enable_offline_survivability_mode,omitempty"`

	// +kubebuilder:validation:Optional
	NoOfflineSurvivabilityMode *bool `json:"noOfflineSurvivabilityMode,omitempty" tf:"no_offline_survivability_mode,omitempty"`
}

type OpenebsEnterpriseObservation struct {
}

type OpenebsEnterpriseParameters struct {

	// +kubebuilder:validation:Optional
	Replication *float64 `json:"replication,omitempty" tf:"replication,omitempty"`

	// +kubebuilder:validation:Optional
	StorageClassSize *float64 `json:"storageClassSize,omitempty" tf:"storage_class_size,omitempty"`
}

type OsObservation struct {
}

type OsParameters struct {

	// +kubebuilder:validation:Optional
	DefaultOsVersion *bool `json:"defaultOsVersion,omitempty" tf:"default_os_version,omitempty"`

	// +kubebuilder:validation:Optional
	OperatingSystemVersion *string `json:"operatingSystemVersion,omitempty" tf:"operating_system_version,omitempty"`
}

type OutsideStaticRoutesObservation struct {

	// +kubebuilder:validation:Optional
	StaticRouteList []OutsideStaticRoutesStaticRouteListObservation `json:"staticRouteList,omitempty" tf:"static_route_list,omitempty"`
}

type OutsideStaticRoutesParameters struct {

	// +kubebuilder:validation:Optional
	StaticRouteList []OutsideStaticRoutesStaticRouteListParameters `json:"staticRouteList,omitempty" tf:"static_route_list,omitempty"`
}

type OutsideStaticRoutesStaticRouteListCustomStaticRouteObservation struct {

	// +kubebuilder:validation:Optional
	Nexthop []StaticRouteListCustomStaticRouteNexthopObservation `json:"nexthop,omitempty" tf:"nexthop,omitempty"`
}

type OutsideStaticRoutesStaticRouteListCustomStaticRouteParameters struct {

	// +kubebuilder:validation:Optional
	Attrs []*string `json:"attrs,omitempty" tf:"attrs,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	Nexthop []StaticRouteListCustomStaticRouteNexthopParameters `json:"nexthop,omitempty" tf:"nexthop,omitempty"`

	// +kubebuilder:validation:Optional
	Subnets []StaticRouteListCustomStaticRouteSubnetsParameters `json:"subnets,omitempty" tf:"subnets,omitempty"`
}

type OutsideStaticRoutesStaticRouteListObservation struct {

	// +kubebuilder:validation:Optional
	CustomStaticRoute []StaticRouteListCustomStaticRouteObservation `json:"customStaticRoute,omitempty" tf:"custom_static_route,omitempty"`
}

type OutsideStaticRoutesStaticRouteListParameters struct {

	// +kubebuilder:validation:Optional
	CustomStaticRoute []StaticRouteListCustomStaticRouteParameters `json:"customStaticRoute,omitempty" tf:"custom_static_route,omitempty"`

	// +kubebuilder:validation:Optional
	SimpleStaticRoute *string `json:"simpleStaticRoute,omitempty" tf:"simple_static_route,omitempty"`
}

type OutsideSubnetObservation struct {
}

type OutsideSubnetParameters struct {

	// +kubebuilder:validation:Optional
	ExistingSubnetID *string `json:"existingSubnetId,omitempty" tf:"existing_subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetParam []OutsideSubnetSubnetParamParameters `json:"subnetParam,omitempty" tf:"subnet_param,omitempty"`
}

type OutsideSubnetSubnetParamObservation struct {
}

type OutsideSubnetSubnetParamParameters struct {

	// +kubebuilder:validation:Optional
	IPv4 *string `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 *string `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type PolicyInterceptionRulesObservation struct {
}

type PolicyInterceptionRulesParameters struct {

	// +kubebuilder:validation:Optional
	DisableInterception *bool `json:"disableInterception,omitempty" tf:"disable_interception,omitempty"`

	// +kubebuilder:validation:Optional
	DomainMatch []InterceptionRulesDomainMatchParameters `json:"domainMatch,omitempty" tf:"domain_match,omitempty"`

	// +kubebuilder:validation:Optional
	EnableInterception *bool `json:"enableInterception,omitempty" tf:"enable_interception,omitempty"`
}

type PolicyObservation struct {
}

type PolicyParameters struct {

	// +kubebuilder:validation:Optional
	InterceptionRules []InterceptionRulesParameters `json:"interceptionRules,omitempty" tf:"interception_rules,omitempty"`
}

type PrivateKeyBlindfoldSecretInfoInternalObservation struct {
}

type PrivateKeyBlindfoldSecretInfoInternalParameters struct {

	// +kubebuilder:validation:Optional
	DecryptionProvider *string `json:"decryptionProvider,omitempty" tf:"decryption_provider,omitempty"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// +kubebuilder:validation:Optional
	StoreProvider *string `json:"storeProvider,omitempty" tf:"store_provider,omitempty"`
}

type PrivateKeyBlindfoldSecretInfoObservation struct {
}

type PrivateKeyBlindfoldSecretInfoParameters struct {

	// +kubebuilder:validation:Optional
	DecryptionProvider *string `json:"decryptionProvider,omitempty" tf:"decryption_provider,omitempty"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// +kubebuilder:validation:Optional
	StoreProvider *string `json:"storeProvider,omitempty" tf:"store_provider,omitempty"`
}

type PrivateKeyClearSecretInfoObservation struct {
}

type PrivateKeyClearSecretInfoParameters struct {

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type PrivateKeyObservation struct {
}

type PrivateKeyParameters struct {

	// +kubebuilder:validation:Optional
	BlindfoldSecretInfo []BlindfoldSecretInfoParameters `json:"blindfoldSecretInfo,omitempty" tf:"blindfold_secret_info,omitempty"`

	// +kubebuilder:validation:Optional
	BlindfoldSecretInfoInternal []BlindfoldSecretInfoInternalParameters `json:"blindfoldSecretInfoInternal,omitempty" tf:"blindfold_secret_info_internal,omitempty"`

	// +kubebuilder:validation:Optional
	ClearSecretInfo []ClearSecretInfoParameters `json:"clearSecretInfo,omitempty" tf:"clear_secret_info,omitempty"`

	// +kubebuilder:validation:Optional
	SecretEncodingType *string `json:"secretEncodingType,omitempty" tf:"secret_encoding_type,omitempty"`

	// +kubebuilder:validation:Optional
	VaultSecretInfo []VaultSecretInfoParameters `json:"vaultSecretInfo,omitempty" tf:"vault_secret_info,omitempty"`

	// +kubebuilder:validation:Optional
	WingmanSecretInfo []WingmanSecretInfoParameters `json:"wingmanSecretInfo,omitempty" tf:"wingman_secret_info,omitempty"`
}

type PrivateKeyVaultSecretInfoObservation struct {
}

type PrivateKeyVaultSecretInfoParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// +kubebuilder:validation:Optional
	SecretEncoding *string `json:"secretEncoding,omitempty" tf:"secret_encoding,omitempty"`

	// +kubebuilder:validation:Optional
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type PrivateKeyWingmanSecretInfoObservation struct {
}

type PrivateKeyWingmanSecretInfoParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type SLOToGlobalDrGlobalVnObservation struct {
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`
}

type SLOToGlobalDrGlobalVnParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type SLOToGlobalDrObservation struct {

	// +kubebuilder:validation:Optional
	GlobalVn []SLOToGlobalDrGlobalVnObservation `json:"globalVn,omitempty" tf:"global_vn,omitempty"`
}

type SLOToGlobalDrParameters struct {

	// +kubebuilder:validation:Optional
	GlobalVn []SLOToGlobalDrGlobalVnParameters `json:"globalVn,omitempty" tf:"global_vn,omitempty"`
}

type SiteLocalControlPlaneObservation struct {
}

type SiteLocalControlPlaneParameters struct {

	// +kubebuilder:validation:Optional
	DefaultLocalControlPlane *bool `json:"defaultLocalControlPlane,omitempty" tf:"default_local_control_plane,omitempty"`

	// +kubebuilder:validation:Optional
	NoLocalControlPlane *bool `json:"noLocalControlPlane,omitempty" tf:"no_local_control_plane,omitempty"`
}

type SliToGlobalDrGlobalVnObservation struct {
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`
}

type SliToGlobalDrGlobalVnParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`
}

type SliToGlobalDrObservation struct {

	// +kubebuilder:validation:Optional
	GlobalVn []GlobalVnObservation `json:"globalVn,omitempty" tf:"global_vn,omitempty"`
}

type SliToGlobalDrParameters struct {

	// +kubebuilder:validation:Optional
	GlobalVn []GlobalVnParameters `json:"globalVn,omitempty" tf:"global_vn,omitempty"`
}

type StaticRouteListCustomStaticRouteNexthopObservation struct {

	// +kubebuilder:validation:Optional
	Interface []CustomStaticRouteNexthopInterfaceObservation `json:"interface,omitempty" tf:"interface,omitempty"`
}

type StaticRouteListCustomStaticRouteNexthopParameters struct {

	// +kubebuilder:validation:Optional
	Interface []CustomStaticRouteNexthopInterfaceParameters `json:"interface,omitempty" tf:"interface,omitempty"`

	// +kubebuilder:validation:Optional
	NexthopAddress []CustomStaticRouteNexthopNexthopAddressParameters `json:"nexthopAddress,omitempty" tf:"nexthop_address,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type StaticRouteListCustomStaticRouteObservation struct {

	// +kubebuilder:validation:Optional
	Nexthop []CustomStaticRouteNexthopObservation `json:"nexthop,omitempty" tf:"nexthop,omitempty"`
}

type StaticRouteListCustomStaticRouteParameters struct {

	// +kubebuilder:validation:Optional
	Attrs []*string `json:"attrs,omitempty" tf:"attrs,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	Nexthop []CustomStaticRouteNexthopParameters `json:"nexthop,omitempty" tf:"nexthop,omitempty"`

	// +kubebuilder:validation:Optional
	Subnets []CustomStaticRouteSubnetsParameters `json:"subnets,omitempty" tf:"subnets,omitempty"`
}

type StaticRouteListCustomStaticRouteSubnetsIPv4Observation struct {
}

type StaticRouteListCustomStaticRouteSubnetsIPv4Parameters struct {

	// +kubebuilder:validation:Optional
	Plen *float64 `json:"plen,omitempty" tf:"plen,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type StaticRouteListCustomStaticRouteSubnetsIPv6Observation struct {
}

type StaticRouteListCustomStaticRouteSubnetsIPv6Parameters struct {

	// +kubebuilder:validation:Optional
	Plen *float64 `json:"plen,omitempty" tf:"plen,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type StaticRouteListCustomStaticRouteSubnetsObservation struct {
}

type StaticRouteListCustomStaticRouteSubnetsParameters struct {

	// +kubebuilder:validation:Optional
	IPv4 []StaticRouteListCustomStaticRouteSubnetsIPv4Parameters `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 []StaticRouteListCustomStaticRouteSubnetsIPv6Parameters `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type StaticRouteListObservation struct {

	// +kubebuilder:validation:Optional
	CustomStaticRoute []CustomStaticRouteObservation `json:"customStaticRoute,omitempty" tf:"custom_static_route,omitempty"`
}

type StaticRouteListParameters struct {

	// +kubebuilder:validation:Optional
	CustomStaticRoute []CustomStaticRouteParameters `json:"customStaticRoute,omitempty" tf:"custom_static_route,omitempty"`

	// +kubebuilder:validation:Optional
	SimpleStaticRoute *string `json:"simpleStaticRoute,omitempty" tf:"simple_static_route,omitempty"`
}

type StorageClassListObservation struct {
}

type StorageClassListParameters struct {

	// +kubebuilder:validation:Optional
	StorageClasses []StorageClassesParameters `json:"storageClasses,omitempty" tf:"storage_classes,omitempty"`
}

type StorageClassesObservation struct {
}

type StorageClassesParameters struct {

	// +kubebuilder:validation:Optional
	DefaultStorageClass *bool `json:"defaultStorageClass,omitempty" tf:"default_storage_class,omitempty"`

	// +kubebuilder:validation:Optional
	OpenebsEnterprise []OpenebsEnterpriseParameters `json:"openebsEnterprise,omitempty" tf:"openebs_enterprise,omitempty"`

	// +kubebuilder:validation:Optional
	StorageClassName *string `json:"storageClassName,omitempty" tf:"storage_class_name,omitempty"`
}

type SubnetParamObservation struct {
}

type SubnetParamParameters struct {

	// +kubebuilder:validation:Optional
	IPv4 *string `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 *string `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type SubnetsIPv4Observation struct {
}

type SubnetsIPv4Parameters struct {

	// +kubebuilder:validation:Optional
	Plen *float64 `json:"plen,omitempty" tf:"plen,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type SubnetsIPv6Observation struct {
}

type SubnetsIPv6Parameters struct {

	// +kubebuilder:validation:Optional
	Plen *float64 `json:"plen,omitempty" tf:"plen,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type SubnetsObservation struct {
}

type SubnetsParameters struct {

	// +kubebuilder:validation:Optional
	IPv4 []SubnetsIPv4Parameters `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 []SubnetsIPv6Parameters `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type SwObservation struct {
}

type SwParameters struct {

	// +kubebuilder:validation:Optional
	DefaultSwVersion *bool `json:"defaultSwVersion,omitempty" tf:"default_sw_version,omitempty"`

	// +kubebuilder:validation:Optional
	VolterraSoftwareVersion *string `json:"volterraSoftwareVersion,omitempty" tf:"volterra_software_version,omitempty"`
}

type TLSInterceptCustomCertificateObservation struct {
}

type TLSInterceptCustomCertificateParameters struct {

	// +kubebuilder:validation:Optional
	CertificateURL *string `json:"certificateUrl,omitempty" tf:"certificate_url,omitempty"`

	// +kubebuilder:validation:Optional
	CustomHashAlgorithms []CustomCertificateCustomHashAlgorithmsParameters `json:"customHashAlgorithms,omitempty" tf:"custom_hash_algorithms,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DisableOcspStapling []CustomCertificateDisableOcspStaplingParameters `json:"disableOcspStapling,omitempty" tf:"disable_ocsp_stapling,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateKey []CustomCertificatePrivateKeyParameters `json:"privateKey,omitempty" tf:"private_key,omitempty"`

	// +kubebuilder:validation:Optional
	UseSystemDefaults []CustomCertificateUseSystemDefaultsParameters `json:"useSystemDefaults,omitempty" tf:"use_system_defaults,omitempty"`
}

type TLSInterceptObservation struct {
}

type TLSInterceptParameters struct {

	// +kubebuilder:validation:Optional
	CustomCertificate []CustomCertificateParameters `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	EnableForAllDomains *bool `json:"enableForAllDomains,omitempty" tf:"enable_for_all_domains,omitempty"`

	// +kubebuilder:validation:Optional
	Policy []PolicyParameters `json:"policy,omitempty" tf:"policy,omitempty"`

	// +kubebuilder:validation:Optional
	TrustedCAURL *string `json:"trustedCaUrl,omitempty" tf:"trusted_ca_url,omitempty"`

	// +kubebuilder:validation:Optional
	VolterraCertificate *bool `json:"volterraCertificate,omitempty" tf:"volterra_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	VolterraTrustedCA *bool `json:"volterraTrustedCa,omitempty" tf:"volterra_trusted_ca,omitempty"`
}

type TLSInterceptPolicyObservation struct {
}

type TLSInterceptPolicyParameters struct {

	// +kubebuilder:validation:Optional
	InterceptionRules []PolicyInterceptionRulesParameters `json:"interceptionRules,omitempty" tf:"interception_rules,omitempty"`
}

type UseSystemDefaultsObservation struct {
}

type UseSystemDefaultsParameters struct {
}

type VPCObservation struct {
}

type VPCParameters struct {

	// +kubebuilder:validation:Optional
	NewVPC []NewVPCParameters `json:"newVpc,omitempty" tf:"new_vpc,omitempty"`

	// +kubebuilder:validation:Optional
	VPCID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`
}

type VaultSecretInfoObservation struct {
}

type VaultSecretInfoParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// +kubebuilder:validation:Optional
	SecretEncoding *string `json:"secretEncoding,omitempty" tf:"secret_encoding,omitempty"`

	// +kubebuilder:validation:Optional
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type VoltstackClusterActiveForwardProxyPoliciesObservation struct {
}

type VoltstackClusterActiveForwardProxyPoliciesParameters struct {

	// +kubebuilder:validation:Optional
	ForwardProxyPolicies []ActiveForwardProxyPoliciesForwardProxyPoliciesParameters `json:"forwardProxyPolicies,omitempty" tf:"forward_proxy_policies,omitempty"`
}

type VoltstackClusterActiveNetworkPoliciesObservation struct {
}

type VoltstackClusterActiveNetworkPoliciesParameters struct {

	// +kubebuilder:validation:Optional
	NetworkPolicies []ActiveNetworkPoliciesNetworkPoliciesParameters `json:"networkPolicies,omitempty" tf:"network_policies,omitempty"`
}

type VoltstackClusterAllowedVipPortCustomPortsObservation struct {
}

type VoltstackClusterAllowedVipPortCustomPortsParameters struct {

	// +kubebuilder:validation:Optional
	PortRanges *string `json:"portRanges,omitempty" tf:"port_ranges,omitempty"`
}

type VoltstackClusterAllowedVipPortObservation struct {
}

type VoltstackClusterAllowedVipPortParameters struct {

	// +kubebuilder:validation:Optional
	CustomPorts []VoltstackClusterAllowedVipPortCustomPortsParameters `json:"customPorts,omitempty" tf:"custom_ports,omitempty"`

	// +kubebuilder:validation:Optional
	UseHTTPHTTPSPort *bool `json:"useHttpHttpsPort,omitempty" tf:"use_http_https_port,omitempty"`

	// +kubebuilder:validation:Optional
	UseHTTPPort *bool `json:"useHttpPort,omitempty" tf:"use_http_port,omitempty"`

	// +kubebuilder:validation:Optional
	UseHTTPSPort *bool `json:"useHttpsPort,omitempty" tf:"use_https_port,omitempty"`
}

type VoltstackClusterAzNodesObservation struct {
}

type VoltstackClusterAzNodesParameters struct {

	// +kubebuilder:validation:Optional
	AwsAzName *string `json:"awsAzName,omitempty" tf:"aws_az_name,omitempty"`

	// +kubebuilder:validation:Optional
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Optional
	LocalSubnet []AzNodesLocalSubnetParameters `json:"localSubnet,omitempty" tf:"local_subnet,omitempty"`
}

type VoltstackClusterGlobalNetworkListObservation struct {

	// +kubebuilder:validation:Optional
	GlobalNetworkConnections []GlobalNetworkListGlobalNetworkConnectionsObservation `json:"globalNetworkConnections,omitempty" tf:"global_network_connections,omitempty"`
}

type VoltstackClusterGlobalNetworkListParameters struct {

	// +kubebuilder:validation:Optional
	GlobalNetworkConnections []GlobalNetworkListGlobalNetworkConnectionsParameters `json:"globalNetworkConnections,omitempty" tf:"global_network_connections,omitempty"`
}

type VoltstackClusterObservation struct {

	// +kubebuilder:validation:Optional
	GlobalNetworkList []VoltstackClusterGlobalNetworkListObservation `json:"globalNetworkList,omitempty" tf:"global_network_list,omitempty"`

	// +kubebuilder:validation:Optional
	OutsideStaticRoutes []VoltstackClusterOutsideStaticRoutesObservation `json:"outsideStaticRoutes,omitempty" tf:"outside_static_routes,omitempty"`
}

type VoltstackClusterOutsideStaticRoutesObservation struct {

	// +kubebuilder:validation:Optional
	StaticRouteList []VoltstackClusterOutsideStaticRoutesStaticRouteListObservation `json:"staticRouteList,omitempty" tf:"static_route_list,omitempty"`
}

type VoltstackClusterOutsideStaticRoutesParameters struct {

	// +kubebuilder:validation:Optional
	StaticRouteList []VoltstackClusterOutsideStaticRoutesStaticRouteListParameters `json:"staticRouteList,omitempty" tf:"static_route_list,omitempty"`
}

type VoltstackClusterOutsideStaticRoutesStaticRouteListObservation struct {

	// +kubebuilder:validation:Optional
	CustomStaticRoute []OutsideStaticRoutesStaticRouteListCustomStaticRouteObservation `json:"customStaticRoute,omitempty" tf:"custom_static_route,omitempty"`
}

type VoltstackClusterOutsideStaticRoutesStaticRouteListParameters struct {

	// +kubebuilder:validation:Optional
	CustomStaticRoute []OutsideStaticRoutesStaticRouteListCustomStaticRouteParameters `json:"customStaticRoute,omitempty" tf:"custom_static_route,omitempty"`

	// +kubebuilder:validation:Optional
	SimpleStaticRoute *string `json:"simpleStaticRoute,omitempty" tf:"simple_static_route,omitempty"`
}

type VoltstackClusterParameters struct {

	// +kubebuilder:validation:Optional
	ActiveForwardProxyPolicies []VoltstackClusterActiveForwardProxyPoliciesParameters `json:"activeForwardProxyPolicies,omitempty" tf:"active_forward_proxy_policies,omitempty"`

	// +kubebuilder:validation:Optional
	ActiveNetworkPolicies []VoltstackClusterActiveNetworkPoliciesParameters `json:"activeNetworkPolicies,omitempty" tf:"active_network_policies,omitempty"`

	// +kubebuilder:validation:Optional
	AllowedVipPort []VoltstackClusterAllowedVipPortParameters `json:"allowedVipPort,omitempty" tf:"allowed_vip_port,omitempty"`

	// +kubebuilder:validation:Optional
	AwsCertifiedHw *string `json:"awsCertifiedHw,omitempty" tf:"aws_certified_hw,omitempty"`

	// +kubebuilder:validation:Optional
	AzNodes []VoltstackClusterAzNodesParameters `json:"azNodes,omitempty" tf:"az_nodes,omitempty"`

	// +kubebuilder:validation:Optional
	DcClusterGroup []DcClusterGroupParameters `json:"dcClusterGroup,omitempty" tf:"dc_cluster_group,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultStorage *bool `json:"defaultStorage,omitempty" tf:"default_storage,omitempty"`

	// +kubebuilder:validation:Optional
	ForwardProxyAllowAll *bool `json:"forwardProxyAllowAll,omitempty" tf:"forward_proxy_allow_all,omitempty"`

	// +kubebuilder:validation:Optional
	GlobalNetworkList []VoltstackClusterGlobalNetworkListParameters `json:"globalNetworkList,omitempty" tf:"global_network_list,omitempty"`

	// +kubebuilder:validation:Optional
	K8SCluster []K8SClusterParameters `json:"k8sCluster,omitempty" tf:"k8s_cluster,omitempty"`

	// +kubebuilder:validation:Optional
	NoDcClusterGroup *bool `json:"noDcClusterGroup,omitempty" tf:"no_dc_cluster_group,omitempty"`

	// +kubebuilder:validation:Optional
	NoForwardProxy *bool `json:"noForwardProxy,omitempty" tf:"no_forward_proxy,omitempty"`

	// +kubebuilder:validation:Optional
	NoGlobalNetwork *bool `json:"noGlobalNetwork,omitempty" tf:"no_global_network,omitempty"`

	// +kubebuilder:validation:Optional
	NoK8SCluster *bool `json:"noK8SCluster,omitempty" tf:"no_k8s_cluster,omitempty"`

	// +kubebuilder:validation:Optional
	NoNetworkPolicy *bool `json:"noNetworkPolicy,omitempty" tf:"no_network_policy,omitempty"`

	// +kubebuilder:validation:Optional
	NoOutsideStaticRoutes *bool `json:"noOutsideStaticRoutes,omitempty" tf:"no_outside_static_routes,omitempty"`

	// +kubebuilder:validation:Optional
	OutsideStaticRoutes []VoltstackClusterOutsideStaticRoutesParameters `json:"outsideStaticRoutes,omitempty" tf:"outside_static_routes,omitempty"`

	// +kubebuilder:validation:Optional
	SmConnectionPublicIP *bool `json:"smConnectionPublicIp,omitempty" tf:"sm_connection_public_ip,omitempty"`

	// +kubebuilder:validation:Optional
	SmConnectionPvtIP *bool `json:"smConnectionPvtIp,omitempty" tf:"sm_connection_pvt_ip,omitempty"`

	// +kubebuilder:validation:Optional
	StorageClassList []StorageClassListParameters `json:"storageClassList,omitempty" tf:"storage_class_list,omitempty"`
}

type WingmanSecretInfoObservation struct {
}

type WingmanSecretInfoParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type WorkloadSubnetObservation struct {
}

type WorkloadSubnetParameters struct {

	// +kubebuilder:validation:Optional
	ExistingSubnetID *string `json:"existingSubnetId,omitempty" tf:"existing_subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetParam []WorkloadSubnetSubnetParamParameters `json:"subnetParam,omitempty" tf:"subnet_param,omitempty"`
}

type WorkloadSubnetSubnetParamObservation struct {
}

type WorkloadSubnetSubnetParamParameters struct {

	// +kubebuilder:validation:Optional
	IPv4 *string `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 *string `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

// AWSVPCSiteSpec defines the desired state of AWSVPCSite
type AWSVPCSiteSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AWSVPCSiteParameters `json:"forProvider"`
}

// AWSVPCSiteStatus defines the observed state of AWSVPCSite.
type AWSVPCSiteStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AWSVPCSiteObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// AWSVPCSite is the Schema for the AWSVPCSites API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,volterra}
type AWSVPCSite struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AWSVPCSiteSpec   `json:"spec"`
	Status            AWSVPCSiteStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AWSVPCSiteList contains a list of AWSVPCSites
type AWSVPCSiteList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AWSVPCSite `json:"items"`
}

// Repository type metadata.
var (
	AWSVPCSite_Kind             = "AWSVPCSite"
	AWSVPCSite_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AWSVPCSite_Kind}.String()
	AWSVPCSite_KindAPIVersion   = AWSVPCSite_Kind + "." + CRDGroupVersion.String()
	AWSVPCSite_GroupVersionKind = CRDGroupVersion.WithKind(AWSVPCSite_Kind)
)

func init() {
	SchemeBuilder.Register(&AWSVPCSite{}, &AWSVPCSiteList{})
}
